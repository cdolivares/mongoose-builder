// Generated by CoffeeScript 1.6.3
/*
  A small mongoose adapter that transforms schemas from class-like coffeescript classes
  into the more idosyncratic mongoose plugin interface
*/


(function() {
  var _;

  _ = require("underscore");

  exports.adapt = function(schema, options, plugin) {
    var _plugin;
    _plugin = function(skema, options) {
      var configuration, fn, instanceMethodDefinition, instanceMethodName, m, pluginMethodDefinition, pluginMethodName, _ref, _ref1, _ref2, _ref3;
      configuration = options.nodeManager.find(options.thisCollectionName).configuration;
      _ref = plugin.prototype;
      for (pluginMethodName in _ref) {
        pluginMethodDefinition = _ref[pluginMethodName];
        if (pluginMethodName === 'constructor') {
          continue;
        }
        skema.method(pluginMethodName, configuration.methods.instance[pluginMethodName] || pluginMethodDefinition);
      }
      _ref1 = configuration.methods.instance;
      for (instanceMethodName in _ref1) {
        instanceMethodDefinition = _ref1[instanceMethodName];
        if (skema.methods[instanceMethodName] == null) {
          skema.methods[instanceMethodName] = instanceMethodDefinition;
        }
      }
      /*
        TODO(chris): Figure out a way to set these virtuals
        in a more intuitive place.  Perhaps take in a virtual
      
        Every model gets a _type_, _models_, and _configuration_ virtual.
        These methods use _ to prevent naming collisions with mongoose.
      
        _type_ is the collection name in mongo
      
        _models_ references initialized drivers and nodeManager
      */

      skema.virtual('_type_').get(function() {
        return options.thisCollectionName;
      });
      skema.statics._type_ = function() {
        return options.thisCollectionName;
      };
      if (options.short_name != null) {
        skema.virtual('_short_name_').get(function() {
          return options.short_name;
        });
      }
      skema.virtual('_models_').get(function() {
        var o;
        o = {
          drivers: options.models,
          nodeManager: options.nodeManager
        };
        return o;
      });
      skema.virtual('_configuration_').get(function() {
        return configuration;
      });
      skema.statics._configuration_ = function() {
        return configuration;
      };
      if (configuration.virtuals != null) {
        _ref2 = configuration.virtuals.get;
        for (m in _ref2) {
          fn = _ref2[m];
          skema.virtual("" + m).get(fn);
        }
        _ref3 = configuration.virtuals.set;
        for (m in _ref3) {
          fn = _ref3[m];
          skema.virtual("" + m).set(fn);
        }
      }
      skema.methods.jsonify = function() {
        var attachedField, dbField, driverConf, finalAttachedName, newName, o, virtualFn, virtualName, _ref4;
        console.log;
        driverConf = this._configuration_.driver;
        o = {};
        for (dbField in driverConf.schema.fields) {
          if (driverConf.schema.clientMappings != null) {
            if ((newName = driverConf.schema.clientMappings[dbField]) != null) {
              o[newName] = this[dbField];
            } else {
              o[dbField] = this[dbField];
            }
          } else {
            o[dbField] = this[dbField];
          }
        }
        if (driverConf.schema.virtualFields != null) {
          _ref4 = driverConf.schema.virtualFields;
          for (virtualName in _ref4) {
            virtualFn = _ref4[virtualName];
            o[virtualName] = virtualFn.call(this);
          }
        }
        if (this._configuration_.attach != null) {
          for (attachedField in this._configuration_.attach) {
            if (this._doc[attachedField] != null) {
              finalAttachedName = attachedField.split(':').pop();
              o[finalAttachedName] = this._doc[attachedField];
            }
          }
        }
        o._id = this._id;
        return o;
      };
      skema.methods.attach = function(name, actor, clbk) {
        var attachments, done,
          _this = this;
        attachments = name.split(',');
        done = _.after(attachments.length, function() {
          return clbk(null, _this);
        });
        return _.each(attachments, function(attachment) {
          if ((_this._configuration_.attach == null) || (_this._configuration_.attach[attachment] == null)) {
            return done();
          } else {
            return _this._configuration_.attach[attachment](_this, actor, function(err, val) {
              if (err == null) {
                _this._doc[attachment] = val;
              }
              return done();
            });
          }
        });
      };
      /*
      unmaps a json field using schema.clientMappings, if they exist.
      function is synchronous.  Since this method is static, we must
      invoke _configuration_ to get it's value.
      */

      return skema.statics.unmap = function(obj) {
        var inverted, k, mappings, o, v;
        mappings = this._configuration_().driver.schema.clientMappings;
        if (mappings == null) {
          return obj;
        }
        inverted = this._configuration_().__invertedFieldMap = this._configuration_().__invertedFieldMap || _.invert(mappings);
        o = {};
        for (k in obj) {
          v = obj[k];
          if (inverted[k] != null) {
            o[inverted[k]] = v;
          } else {
            o[k] = v;
          }
        }
        return o;
      };
    };
    return schema.plugin(_plugin, options);
  };

}).call(this);

// Generated by CoffeeScript 1.6.2
/*
  A small mongoose adapter that transforms schemas from class-like coffeescript classes
  into the more idosyncratic mongoose plugin interface
*/


(function() {
  exports.adapt = function(schema, options, plugin) {
    var _plugin;

    _plugin = function(skema, options) {
      var configuration, fn, instanceMethodDefinition, instanceMethodName, m, pluginMethodDefinition, pluginMethodName, _ref, _ref1, _ref2, _ref3, _results;

      configuration = options.nodeManager.find(options.thisCollectionName).configuration;
      _ref = plugin.prototype;
      for (pluginMethodName in _ref) {
        pluginMethodDefinition = _ref[pluginMethodName];
        if (pluginMethodName === 'constructor') {
          continue;
        }
        skema.methods[pluginMethodName] = configuration.methods.instance[pluginMethodName] || pluginMethodDefinition;
      }
      _ref1 = configuration.methods.instance;
      for (instanceMethodName in _ref1) {
        instanceMethodDefinition = _ref1[instanceMethodName];
        if (skema.methods[instanceMethodName] == null) {
          skema.methods[instanceMethodName] = instanceMethodDefinition;
        }
      }
      /*
        TODO(chris): Figure out a way to set these virtuals
        in a more intuitive place.  Perhaps take in a virtual
      
        Every model gets a _type_ and _models_ virtual.
        These methods use _ to prevent naming collisions.
      
        _type_ is the collection name in mongo
      
        _models_ references initialized drivers and nodeManager
      */

      skema.virtual('_type_').get(function() {
        return options.thisCollectionName;
      });
      skema.statics._type_ = function() {
        return options.thisCollectionName;
      };
      if (options.short_name != null) {
        skema.virtual('_short_name_').get(function() {
          return options.short_name;
        });
      }
      skema.virtual('_models_').get(function() {
        var o;

        o = {
          drivers: options.models,
          nodeManager: options.nodeManager
        };
        return o;
      });
      if (configuration.virtuals != null) {
        _ref2 = configuration.virtuals.get;
        for (m in _ref2) {
          fn = _ref2[m];
          skema.virtual("" + m).get(fn);
        }
        _ref3 = configuration.virtuals.set;
        _results = [];
        for (m in _ref3) {
          fn = _ref3[m];
          _results.push(skema.virtual("" + m).set(fn));
        }
        return _results;
      }
    };
    return schema.plugin(_plugin, options);
  };

}).call(this);

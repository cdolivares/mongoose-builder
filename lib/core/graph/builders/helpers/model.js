// Generated by CoffeeScript 1.4.0
(function() {
  var ModelInitializer, ObjectId, Schema, mongoose, _MongooseAdapter,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  mongoose = require("mongoose");

  Schema = mongoose.Schema;

  ObjectId = Schema.Types.ObjectId;

  _MongooseAdapter = require("./_adapter");

  /*
  Specific plugins
  */


  ModelInitializer = (function() {
    /*
        Method: constructor
    */

    function ModelInitializer(relations, rawSchemas, plugins) {
      this._lowercasePlural = __bind(this._lowercasePlural, this);

      this._addEmbeddedFields = __bind(this._addEmbeddedFields, this);

      this._addIndices = __bind(this._addIndices, this);

      this._initSchemas = __bind(this._initSchemas, this);

      this._expandTypedPaths = __bind(this._expandTypedPaths, this);

      this.get = __bind(this.get, this);

      this.createModels = __bind(this.createModels, this);

      this.addSchemaPlugins = __bind(this.addSchemaPlugins, this);

      this.prepSchemas = __bind(this.prepSchemas, this);
      this._relations = relations;
      this._rawSchemas = rawSchemas;
      this._plugins = plugins;
      this._models = {};
    }

    /*
        Method: prepSchemas
    
        Initializes mongoose schemas with mongoose specific
        schema format.
    */


    ModelInitializer.prototype.prepSchemas = function(callback) {
      this._expandTypedPaths();
      this._schemas = this._initSchemas();
      return callback(null);
    };

    /*
        Method: addSchemaPlugins
    
        Determines each resource type and enriches
        it with the appropriate plugin.
    */


    ModelInitializer.prototype.addSchemaPlugins = function(callback) {
      var options, plugin, resourceDef, resourceName, schema, schemaName, _ref;
      _ref = this._relations;
      for (resourceName in _ref) {
        resourceDef = _ref[resourceName];
        if (resourceDef.store.type !== 'mongo') {
          console.log("Ignoring " + resourceName + " because it's not store mongo");
          continue;
        }
        schemaName = resourceDef.store.modelName;
        schema = this._schemas[schemaName];
        options = {
          models: this._models,
          schemas: this._schemas,
          sName: schemaName
        };
        plugin = this._plugins[resourceDef.type];
        if (plugin != null) {
          console.log("Enriching schema " + schemaName);
          _MongooseAdapter.adapt(schema, options, plugin);
        } else {
          console.log("No plugin for " + resourceDef.type);
        }
      }
      return callback(null);
    };

    /*
        Method: createModels
    
        Creates mongoose models from a set of passed in
        connection objects.  Connections are a hash with
        keys specifying the database type. For now there
        should only really be
    
          awardrecords:
            <conn object>
          default:
            <conn object>
    */


    ModelInitializer.prototype.createModels = function(connections, callback) {
      var db, modelName, _ref;
      _ref = this._schemas;
      for (modelName in _ref) {
        Schema = _ref[modelName];
        if (modelName === "AwardRecord") {
          db = connections['awardrecords'];
        } else {
          db = connections['default'];
        }
        this._models[modelName] = db.model(modelName, Schema);
      }
      return callback(null);
    };

    /*
        Method: get
    
        Returns model instances
    */


    ModelInitializer.prototype.get = function() {
      return this._models;
    };

    ModelInitializer.prototype.__defineGetter__('schemas', function() {
      return this._schemas;
    });

    /*
        private methods
    */


    /*
        Private Method: _expandTypedPaths
    
        Expands schema fields from embedded objects
          field1: {
            field2: "val"
          }
        into dot notation
    
        field1.field2 = "val"
    */


    ModelInitializer.prototype._expandTypedPaths = function(rawSchemas) {
      var field, fieldVal, schemaDefn, schemaName, typedSchema, _buildPath, _results,
        _this = this;
      _buildPath = function(field, fieldVal, typedSchema) {
        var nestedField, nestedKey, _results;
        if (_.isString(fieldVal)) {
          return typedSchema[field] = fieldVal;
        } else {
          _results = [];
          for (nestedKey in fieldVal) {
            nestedField = fieldVal[nestedKey];
            _results.push(_buildPath("" + field + "." + nestedKey, nestedField, typedSchema));
          }
          return _results;
        }
      };
      _results = [];
      for (schemaName in rawSchemas) {
        schemaDefn = rawSchemas[schemaName];
        typedSchema = schemaDefn.typed;
        _results.push((function() {
          var _results1;
          _results1 = [];
          for (field in typedSchema) {
            fieldVal = typedSchema[field];
            _results1.push(_buildPath(field, fieldVal, typedSchema));
          }
          return _results1;
        })());
      }
      return _results;
    };

    /*
        Private Method: _initSchemas
    
        Initializes mongoose schema objects adding
        indices and embedded documents.
    
        eg.
          Schema =
            typed:
              "field1": "String"
            indices:
              [{"field1": 1}]
            embed:
              "field2": ["SomeOtherSchema"]
    
        field1 is indexed and field2 is added as embedding
        SomeOtherSchema
    */


    ModelInitializer.prototype._initSchemas = function() {
      var d, name, s, schema, schemaName, schemas, _ref;
      schemas = {};
      _ref = this._rawSchemas;
      for (name in _ref) {
        d = _ref[name];
        s = new Schema(d.fields, {
          collection: utils.pluralize(name.toLowerCase())
        });
        this._addIndices(s, d);
        schemas[name] = s;
      }
      for (schemaName in schemas) {
        schema = schemas[schemaName];
        this._addEmbeddedFields(schemaName, schema, schemas);
      }
      return schemas;
    };

    /*
        Private Method: _addIndices
    
        Adds indices to a schema. Called by _initSchemas
    */


    ModelInitializer.prototype._addIndices = function(schema, rawSchema) {
      var index, _i, _len, _ref, _results;
      if (rawSchema.indices != null) {
        _ref = rawSchema.indices;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          index = _ref[_i];
          _results.push(schema.index.apply(schema, index));
        }
        return _results;
      }
    };

    /*
        Private Method: _addEmbeddedFields
    
        Adds embedded fields to schema. Callbed by _addEmbeddedFields
    */


    ModelInitializer.prototype._addEmbeddedFields = function(schemaName, schemaToAdd, allSchemas) {
      var embeddedSchema, field, obj, rawSchema, sVal, _ref, _results;
      rawSchema = this._rawSchemas[schemaName];
      if (rawSchema.embed != null) {
        _ref = rawSchema.embed;
        _results = [];
        for (field in _ref) {
          embeddedSchema = _ref[field];
          obj = {};
          if (_.isArray(embeddedSchema)) {
            sVal = [allSchemas[embeddedSchema[0]]];
          } else {
            sVal = allSchemas[embeddedSchema];
          }
          obj[field] = sVal;
          _results.push(schemaToAdd.add(obj));
        }
        return _results;
      }
    };

    ModelInitializer.prototype._lowercasePlural = function(name) {
      name = name.toLowerCase();
      name = name + "s";
      return name;
    };

    return ModelInitializer;

  })();

  module.exports = ModelInitializer;

}).call(this);
